# 全体的な今回のプロジェクトにおける反省点
# 1. t_screenに全てを詰め込み過ぎた
#    どう解決するべきかは分からないけど、mutexのロックがかなり非効率なことになってる気がする
#    あと単純にもっと下位の構造体に分けることもできた（その場合参照が面倒だから一長一短ではある
#
# 2. メモリの管理から大分逃げている
#    reallocをさせても基本的に問題ないんだけど、長時間プレイしてるとエラー吐いてプログラムが緊急停止してしまう
#    そのため事前に持っておくサイズをかなり大きめに取り、事実上reallocが発生しないようにしてしまった
#    スレッドの管理をしながらメモリ管理をする、というので何か難易度が上がっているのか…　その点についてもよく分かっておらず、それが何より良くない（勉強になってないので
#    また、mainからexitした時に起こるリークについても無視してしまった。実用上問題はないが…　厳密にプログラムを作る時には問題になりそうだしよくない
#
# 3. ゲームとして微妙
#    まあステージデザインとかをガチるつもりは無いので仕方ないけど、ノーマル1ステージしか無いのはちょっと
#    ボムも結局実装できていない
#
# 4. 多分、弾と敵を別々の配列に入れる必要はなかった
#    どっちを取るかという話にはなる 弾と敵を別々にしたことで当たり判定を実装するのは楽だった
#    一方でcreate系が面倒になった

NAME := Shooting.exe
CC := gcc
RM := del
MAKE := mingw32-make

INCLUDE := include/
SRC_DIR := src/
OBJ_DIR := obj/

CFLAGS :=-Wextra -Wall -fdiagnostics-show-option -Wfloat-equal -Wconversion -fexec-charset=cp932 -O2 -I $(INCLUDE)

# ToDo
# ドキュメント作る
# unixにも対応できるようにする(conio 気が向いたらncusersに, あとfflush)
# 同時入力可能に(どっちかを読んだあとにまだバッファが残ってたら読む?)
# スコア・スクロール・ステージの実装
#
# ステージの実装について
#   /ステージ.txtの生成規則
#   画面描画で～…エスケープシーケンスで色つけるならその分変わってきちゃうよね
#   背景色, その場所にある文字, その文字の色 この3種
#   alphabetが敵、*が弾、それ以外がアイテムとか場所とか？
#   敵の弾は+, 強化アイテムはxにしよう
#   ボムは#記号 // ボムはまだ実装してない
#   待って アイテムの色を指定できない ええと xは赤色、Xは青色、zは黄色、Zは緑色　ってことにしよう
#   赤は貫通、青は横で反射、黄色は複数、緑は上で反射
#   スペースは白、#は樹木、みたいな感じにしてもいいかも? そしたらステージデザインが楽
#   雑魚は小文字、ボスが大文字 ボム実装したい あと弾幕撃つ敵ね
#   ステージの最初に情報として何ステージあります、難易度は3種類です みたいにしたら難易度も実装できるね
#
#   /ステージ.txtの読み込み規則
#   なんかー…最初に何ステージあるか調べて？ そのあと画面分読み込み?
#   ステージバッファの配列で管理して、hが押されたらヘルプ、空白かエンターでゲームスタートの画面番号に
#   mallocでステージバッファを一時的に取得しよう
#   空行は読み飛ばす処理で
#   最初のステージ生成の時に#だったら背景を緑、#を文字に ってやる
#   背景文字が敵や自機が移動した後に消えちゃう つまりdraw_screen中で常に参照する必要がある
#
#   /ステージを実装するに当たって必要な既存コードの改変
#   t_panel の実装
#   t_screenにt_panel **を持たせる
#   levelはハードだと1 みたいな レベルに応じて読み飛ばす?
#   枠線面倒だから上にスコア、下にボムと残機でいいかも
#   弾は色で管理したら面白いかも(赤が貫通, 青が拡散, 緑が反射とかね)
#
#   /ステージ作った後にそれを応用してできること
#   ゲームの読み込み画面作りたい! 最初のやつ! あれでヘルプとか見れるようにしようよ!
#   スクロールの表現 t_panel bufを1行ずつズラしていく(何フレームに1行? defineで決めて良い)
#   多分スクロールはカウンターを増やしていってそれがゼロになったらにする
#   マックスカウンターをdefineで決める fpsに応じて何秒になるか(60fpsだったら30fに一度で0.5秒になるよね)
#
#   最初の画面を実装するのにはthreadのループを始める前に簡単なループ関数を渡せばいいだけだよ
#
# 同期処理(画面描画と入力～)?
# 空間分割かスキャンラインの実装?
#
#
# コメントの仕方
#  役割を書く 個別の役割は関数名や変数名で分かるので
#  全体を通した設計思想・一群を纏めた際の処理
#  →ドキュメント化する際にはどこに何が紐づいていて関わっているのか
#  main->3種に分岐して... それぞれがこういう処理を呼び出していて... ネットワーク的な
#  大まかな流れ それぞれのソースの役割とか(detectionは何をしていますよ…)
#  ex. object.cはオブジェクトの生成と管理を司っている
#  ドキュメントにヘッダファイルに色々書いてあるからちゃんと読んでね とか
#  ドキュメントにアクセスしたら必要な情報がある程度分かるようにする
#  プログラムだけでやるんだったら先頭にコメントで情報を付加する(先ほどのこのファイルは○○を...
#  情報工学の基礎が無くても分かるように
#  次にこのコードを読む人のためのことを思う(コード単位ではできてたと思うけどコメントの面では全くできていなかった
#
# 巨人の肩に乗れ
#
#
# // ToDo
#
# なんかラスボスくんが出てこない


ifdef WITH_DEBUG
	CFLAGS +=-g3 -O0 -DDEBUG
endif

ifeq ($(OS), Windows_NT)
    CFLAGS += -DWIN
endif

SRC := $(wildcard $(SRC_DIR)*.c)
OBJ := $(addprefix $(OBJ_DIR), $(notdir $(SRC:.c=.o)))

#command
all: $(NAME)

$(NAME): $(OBJ)
	$(CC) $(CFLAGS) -o $(NAME) $(OBJ)

$(OBJ_DIR)%.o:$(SRC_DIR)%.c
	$(CC) $(CFLAGS) -c $< -o $@

clean: $(OBJ)
	$(RM) $(subst /,\,$^)

fclean:clean
	$(RM) $(NAME)

re:fclean all

debug:
	$(MAKE) WITH_DEBUG=1

.PHONY: all clean fclean re debug